# 列式存储

好的！让我们通过一个具体的例子，深入剖析列存储（Columnar Storage）为何特别适合分析型查询（OLAP），尤其是像 `SELECT AVG(销售额) FROM 亿级订单表` 这样的聚合操作。我会从存储原理、I/O优化机制和实际性能对比三个层面展开说明。

---

**一、行存储 vs 列存储的底层逻辑**
**1. 行存储（OLTP场景）如何工作？**
• 存储方式：数据按行连续存储（例如：订单ID、用户ID、商品ID、销售额、下单时间等字段逐行排列）。  

  ```plaintext
  行存储示例（每行数据紧挨着存储）：
  | 订单ID | 用户ID | 商品ID | 销售额 | 下单时间       |
  |-------|-------|-------|-------|---------------|
  | 1001  | 501   | 901   | 299   | 2023-01-01 10:00 |
  | 1002  | 502   | 902   | 599   | 2023-01-01 10:01 |
  ...（上亿条记录）
  ```
• 查询痛点：  

  执行 `SELECT AVG(销售额)` 时，必须从磁盘读取整行数据（包括无关的订单ID、用户ID等字段），导致大量无效I/O。

**2. 列存储（OLAP场景）如何工作？**
• 存储方式：数据按列分开存储（所有订单ID存在一起，所有销售额存在一起……）。  

  ```plaintext
  列存储示例（每列数据单独存储）：
  订单ID列: [1001, 1002, 1003, ...]
  用户ID列: [501, 502, 503, ...]
  销售额列: [299, 599, 199, ...]
  下单时间列: ["2023-01-01 10:00", "2023-01-01 10:01", ...]
  ```
• 查询优势：  

  执行 `SELECT AVG(销售额)` 时，只需读取销售额这一列的数据，其他列完全不需要加载。

---

**二、I/O优化原理详解（以亿级订单表为例）**
**1. I/O数据量对比**
• 行存储的I/O：  

  假设单行数据1KB（含所有字段），1亿行数据总大小约100GB。  
  计算平均值需读取所有行的销售额字段（假设销售额占8字节），但实际I/O仍需加载整个100GB数据（因为磁盘按块读取，无法只取部分字段）。

• 列存储的I/O：  

  销售额列单独存储，1亿条销售额数据约800MB（8字节×1亿）。  
  查询时仅需读取800MB数据，比行存储减少99%以上的I/O量！

**2. 磁盘读取效率**
• 行存储的随机访问：  

  即使有索引，大量随机I/O（因为数据分散在各行）导致磁盘寻道时间成为瓶颈（机械硬盘尤其明显）。

• 列存储的顺序访问：  

  同一列数据连续存储，顺序读取（Sequential Read）速度可达随机读取的10-100倍（SSD同样受益）。

**3. 压缩效率加成**
• 列存储的压缩优势：  

  同一列的数据类型和模式高度相似（例如销售额都是数值，下单时间都是时间戳），压缩率极高。  
  • 例如：销售额列可用`Delta Encoding + RLE`压缩（相邻数值差+重复值计数），压缩后可能仅占原始大小的10%。  

  • 实际I/O量可能从800MB降至80MB！


---

**三、执行流程对比（以AVG计算为例）**
**行存储的执行路径**
1. 从磁盘读取100GB数据到内存  
2. 解析每一行，提取销售额字段  
3. 累加销售额并计算平均值  
4. 瓶颈：大量时间浪费在读取和解析无关数据上。

**列存储的执行路径**
1. 从磁盘读取销售额列（压缩后可能仅80MB）  
2. 直接对连续的销售额数据流做累加  
3. 计算平均值  
4. 加速点：I/O量少、无需解析行结构、CPU缓存命中率高。

---

**四、高级优化技术**
列存储系统还会结合以下技术进一步加速分析查询：
1. 向量化执行（Vectorized Processing）：  
   • 每次处理一批数据（而非单行），利用CPU SIMD指令并行计算。  

   • 例如：用AVX-512指令同时计算100个销售额的累加。


2. 延迟物化（Late Materialization）：  
   • 仅在最终需要时合并多列数据（减少中间结果传输）。  

   • 例如：`SELECT AVG(销售额) WHERE 用户ID=500` 先过滤用户ID列，再读取对应位置的销售额。


3. 列组（Column Group）：  
   • 对常一起查询的列（如商品ID和商品名称）特殊存储，平衡灵活性和性能。


---

**五、性能对比实验**
假设1亿条订单数据，在相同硬件上：
| 指标       | 行存储（MySQL） | 列存储（ClickHouse） |
|----------------|--------------------|-------------------------|
| 查询耗时       | 120秒              | 0.8秒                   |
| 磁盘读取量     | 100GB              | 80MB（压缩后）          |
| CPU利用率      | 30%（I/O等待为主） | 90%（全力计算）         |

---

**六、教学建议**
• 课堂演示：  

  1. 用Python生成模拟数据集（1千万行即可），分别存为CSV（行式）和Parquet（列式）。  
  2. 用`pandas`执行相同聚合查询，对比耗时（列式快10倍以上）。  
• 思考题：  

  *"如果查询是`SELECT * FROM 订单表 WHERE 订单ID=1001`，列存储还会更快吗？为什么？"*  
  （答案：行存储更快，因为列存储需合并多列数据）  

通过这种对比，学生能直观理解"列存储用空间换时间"的本质，以及OLAP系统设计的核心思想。
